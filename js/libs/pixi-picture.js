this.PIXI=this.PIXI||{},this.PIXI.picture=this.PIXI.picture||{},function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("@pixi/core"),require("@pixi/constants"),require("@pixi/sprite"),require("@pixi/sprite-tiling"),require("@pixi/math")):"function"==typeof define&&define.amd?define(["exports","@pixi/core","@pixi/constants","@pixi/sprite","@pixi/sprite-tiling","@pixi/math"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self)._pixi_picture={},e.PIXI,e.PIXI,e.PIXI,e.PIXI,e.PIXI)}(this,function(e,r,t,n,i,s){"use strict";class o extends r.Filter{constructor(){super(...arguments),this.backdropUniformName=null,this._backdropActive=!1,this.clearColor=null}}const l="\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D uBackdrop;\nuniform vec2 uBackdrop_flipY;\n\n%UNIFORM_CODE%\n\nvoid main(void)\n{\n   vec2 backdropCoord = vec2(vTextureCoord.x, uBackdrop_flipY.x + uBackdrop_flipY.y * vTextureCoord.y);\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\n   vec4 b_dest = texture2D(uBackdrop, backdropCoord);\n   vec4 b_res = b_dest;\n   \n   %BLEND_CODE%\n\n   gl_FragColor = b_res;\n}";class u extends o{constructor(e){let r=l;super(void 0,r=(r=r.replace("%UNIFORM_CODE%",e.uniformCode||"")).replace("%BLEND_CODE%",e.blendCode||""),e.uniforms),this.backdropUniformName="uBackdrop"}}const a="\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec2 flipY;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vTextureCoord.y = flipY.x + flipY.y * vTextureCoord.y;\n}\n\n";class c extends r.Filter{constructor(e,r){const t=r||{};t.flipY||(t.flipY=new Float32Array([0,1])),super(a,e,t)}}var p;e.MASK_CHANNEL=void 0,(p=e.MASK_CHANNEL||(e.MASK_CHANNEL={}))[p.RED=0]="RED",p[p.GREEN=1]="GREEN",p[p.BLUE=2]="BLUE",p[p.ALPHA=3]="ALPHA";class d{constructor(r=!1,t=e.MASK_CHANNEL.ALPHA){this.maskBefore=r,this.uniformCode="uniform vec4 uChannel;",this.uniforms={uChannel:new Float32Array([0,0,0,0])},this.blendCode="b_res = dot(b_src, uChannel) * b_dest;",this.safeFlipY=!1,this.uniforms.uChannel[t]=1}}const h=new Float32Array([0,1]);class f extends u{constructor(e,r=new d){super(r),this.baseFilter=e,this.config=r,this.padding=e.padding,this.safeFlipY=r.safeFlipY}apply(e,r,n,i){const s=e.getFilterTexture(r);if(this.config.maskBefore){const{blendMode:o}=this.state;this.state.blendMode=t.BLEND_MODES.NONE,e.applyFilter(this,r,s,t.CLEAR_MODES.YES),this.baseFilter.blendMode=o,this.baseFilter.apply(e,s,n,i),this.state.blendMode=o}else{const{uBackdrop:o,uBackdrop_flipY:l}=this.uniforms;if(l[1]>0||this.safeFlipY)this.baseFilter.apply(e,o,s,t.CLEAR_MODES.YES);else{const n=e.getFilterTexture(r);f._flipYFilter||(f._flipYFilter=new c),f._flipYFilter.uniforms.flipY[0]=l[0],f._flipYFilter.uniforms.flipY[1]=l[1],f._flipYFilter.apply(e,o,n,t.CLEAR_MODES.YES),this.baseFilter.apply(e,n,s,t.CLEAR_MODES.YES),e.returnFilterTexture(n),this.uniforms.uBackdrop_flipY=h}this.uniforms.uBackdrop=s,e.applyFilter(this,r,n,i),this.uniforms.uBackdrop=o,this.uniforms.uBackdrop_flipY=l}e.returnFilterTexture(s)}}f._flipYFilter=null;const b="if (b_src.a == 0.0) {\n  gl_FragColor = vec4(0, 0, 0, 0);\n  return;\n}\nif (b_dest.a == 0.0) {\n  gl_FragColor = b_src;\n  return;\n}\nvec3 Cb = b_dest.rgb / b_dest.a;\nvec3 Cs = b_src.rgb / b_src.a;\n%NPM_BLEND%\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\nb_res.rgb = (1.0 - b_dest.a) * Cs + b_dest.a * B;\nb_res.rgb *= b_res.a;\n",m="vec3 multiply = Cb * Cs * 2.0;\nvec3 Cb2 = Cb * 2.0 - 1.0;\nvec3 screen = Cb2 + Cs - Cb2 * Cs;\nvec3 B;\nif (Cs.r <= 0.5) {\n  B.r = multiply.r;\n} else {\n  B.r = screen.r;\n}\nif (Cs.g <= 0.5) {\n  B.g = multiply.g;\n} else {\n  B.g = screen.g;\n}\nif (Cs.b <= 0.5) {\n  B.b = multiply.b;\n} else {\n  B.b = screen.b;\n}\n",F="vec3 multiply = Cb * Cs * 2.0;\nvec3 Cs2 = Cs * 2.0 - 1.0;\nvec3 screen = Cb + Cs2 - Cb * Cs2;\nvec3 B;\nif (Cb.r <= 0.5) {\n  B.r = multiply.r;\n} else {\n  B.r = screen.r;\n}\nif (Cb.g <= 0.5) {\n  B.g = multiply.g;\n} else {\n  B.g = screen.g;\n}\nif (Cb.b <= 0.5) {\n  B.b = multiply.b;\n} else {\n  B.b = screen.b;\n}\n",C="vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\nvec3 B;\nvec3 D;\nif (Cs.r <= 0.5)\n{\n  B.r = first.r;\n}\nelse\n{\n  if (Cb.r <= 0.25)\n  {\n    D.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \n  }\n  else\n  {\n    D.r = sqrt(Cb.r);\n  }\n  B.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\n}\nif (Cs.g <= 0.5)\n{\n  B.g = first.g;\n}\nelse\n{\n  if (Cb.g <= 0.25)\n  {\n    D.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \n  }\n  else\n  {\n    D.g = sqrt(Cb.g);\n  }\n  B.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\n}\nif (Cs.b <= 0.5)\n{\n  B.b = first.b;\n}\nelse\n{\n  if (Cb.b <= 0.25)\n  {\n    D.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \n  }\n  else\n  {\n    D.b = sqrt(Cb.b);\n  }\n  B.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\n}\n",g=b.replace("%NPM_BLEND%",m),x=b.replace("%NPM_BLEND%",F),_=b.replace("%NPM_BLEND%",C),y=b.replace("%NPM_BLEND%","vec3 B = Cs * Cb;\n"),T=[];T[t.BLEND_MODES.MULTIPLY]=y,T[t.BLEND_MODES.OVERLAY]=g,T[t.BLEND_MODES.HARD_LIGHT]=x,T[t.BLEND_MODES.SOFT_LIGHT]=_;let B=[],E=[];function v(e){return T[e]?(B[e]||(B[e]=new u({blendCode:T[e]})),B[e]):null}function L(e){return T[e]?(E[e]||(E[e]=[v(e)]),E[e]):null}function D(e,r=0){const{gl:t}=this;this.currentLocation!==r&&(this.currentLocation=r,t.activeTexture(t.TEXTURE0+r)),this.bind(e,r)}const M=new s.Matrix;function A(e,t,n=!0){const i=this.renderer,s=this.defaultFilterStack,o=this.statePool.pop()||new r.FilterState,l=this.renderer.renderTexture;let u=t[0].resolution,a=t[0].padding,c=t[0].autoFit,p=t[0].legacy;for(let e=1;e<t.length;e++){const r=t[e];u=Math.min(u,r.resolution),a=this.useMaxPadding?Math.max(a,r.padding):a+r.padding,c=c&&r.autoFit,p=p||r.legacy}1===s.length&&(this.defaultFilterStack[0].renderTexture=l.current),s.push(o),o.resolution=u,o.legacy=p,o.target=e,o.sourceFrame.copyFrom(e.filterArea||e.getBounds(!0)),o.sourceFrame.pad(a);let d=!0;if(c){const e=this.tempRect.copyFrom(l.sourceFrame);i.projection.transform&&this.transformAABB(M.copyFrom(i.projection.transform).invert(),e),o.sourceFrame.fit(e)}else d=function(e,r){let t=r.x+r.width,n=r.y+r.height,i=e.x+e.width,s=e.y+e.height;return r.x>=e.x&&r.x<=i&&r.y>=e.y&&r.y<=s&&t>=e.x&&t<=i&&n>=e.y&&n<=s}(this.renderer.renderTexture.sourceFrame,o.sourceFrame);if(n&&o.sourceFrame.width<=1&&o.sourceFrame.height<=1)return s.pop(),o.clear(),this.statePool.push(o),!1;if(this.roundFrame(o.sourceFrame,l.current?l.current.resolution:i.resolution,l.sourceFrame,l.destinationFrame,i.projection.transform),o.sourceFrame.ceil(u),d){let e=null,r=null;for(let n=0;n<t.length;n++){const i=t[n].backdropUniformName;if(i){const{uniforms:s}=t[n];s[i+"_flipY"]||(s[i+"_flipY"]=new Float32Array([0,1]));const l=s[i+"_flipY"];null===e?(e=this.prepareBackdrop(o.sourceFrame,l),r=l):(l[0]=r[0],l[1]=r[1]),s[i]=e,e&&(t[n]._backdropActive=!0)}}e&&(u=o.resolution=e.resolution)}o.renderTexture=this.getOptimalFilterTexture(o.sourceFrame.width,o.sourceFrame.height,u),o.filters=t,o.destinationFrame.width=o.renderTexture.width,o.destinationFrame.height=o.renderTexture.height;const h=this.tempRect;h.x=0,h.y=0,h.width=o.sourceFrame.width,h.height=o.sourceFrame.height,o.renderTexture.filterFrame=o.sourceFrame,o.bindingSourceFrame.copyFrom(l.sourceFrame),o.bindingDestinationFrame.copyFrom(l.destinationFrame),o.transform=i.projection.transform,i.projection.transform=null,l.bind(o.renderTexture,o.sourceFrame,h);const f=t[t.length-1].clearColor;return f?i.framebuffer.clear(f[0],f[1],f[2],f[3]):i.framebuffer.clear(0,0,0,0),!0}function N(e,r){return this.pushWithCheck(e,r,!1)}function S(){const e=this.defaultFilterStack,r=e.pop(),n=r.filters;this.activeState=r;const i=this.globalUniforms.uniforms;i.outputFrame=r.sourceFrame,i.resolution=r.resolution;const s=i.inputSize,o=i.inputPixel,l=i.inputClamp;if(s[0]=r.destinationFrame.width,s[1]=r.destinationFrame.height,s[2]=1/s[0],s[3]=1/s[1],o[0]=s[0]*r.resolution,o[1]=s[1]*r.resolution,o[2]=1/o[0],o[3]=1/o[1],l[0]=.5*o[2],l[1]=.5*o[3],l[2]=r.sourceFrame.width*s[2]-.5*o[2],l[3]=r.sourceFrame.height*s[3]-.5*o[3],r.legacy){const e=i.filterArea;e[0]=r.destinationFrame.width,e[1]=r.destinationFrame.height,e[2]=r.sourceFrame.x,e[3]=r.sourceFrame.y,i.filterClamp=i.inputClamp}this.globalUniforms.update();const u=e[e.length-1];if(r.renderTexture.framebuffer.multisample>1&&this.renderer.framebuffer.blit(),1===n.length)n[0].apply(this,r.renderTexture,u.renderTexture,t.CLEAR_MODES.BLEND,r),this.returnFilterTexture(r.renderTexture);else{let e=r.renderTexture,i=this.getOptimalFilterTexture(e.width,e.height,r.resolution);i.filterFrame=e.filterFrame;let s=0;for(s=0;s<n.length-1;++s){n[s].apply(this,e,i,t.CLEAR_MODES.CLEAR,r);const o=e;e=i,i=o}n[s].apply(this,e,u.renderTexture,t.CLEAR_MODES.BLEND,r),this.returnFilterTexture(e),this.returnFilterTexture(i)}let a=!1;for(let e=0;e<n.length;e++)if(n[e]._backdropActive){const r=n[e].backdropUniformName;a||(this.returnFilterTexture(n[e].uniforms[r]),a=!0),n[e].uniforms[r]=null,n[e]._backdropActive=!1}r.clear(),this.statePool.push(r)}let P=!1;function Y(e,r){const t=this.renderer,n=t.renderTexture.current,i=this.renderer.renderTexture.sourceFrame,o=t.projection.transform||s.Matrix.IDENTITY;let l=1;if(n)l=n.baseTexture.resolution,r[1]=1;else{if(!t.useContextAlpha)return P||(P=!0,console.warn("pixi-picture: you are trying to use Blend Filter on main framebuffer! That wont work.")),null;l=t.resolution,r[1]=-1}const u=Math.round((e.x-i.x+o.tx)*l),a=e.y-i.y+o.ty,c=Math.round((r[1]<0?i.height-(a+e.height):a)*l),p=Math.round(e.width*l),d=Math.round(e.height*l),h=t.gl,f=this.getOptimalFilterTexture(p,d,1);return r[1]<0&&(r[0]=d/f.height),f.filterFrame=i,f.setResolution(l),t.texture.bindForceLocation(f.baseTexture,0),h.copyTexSubImage2D(h.TEXTURE_2D,0,0,0,u,c,p,d),f}function k(){r.TextureSystem.prototype.bindForceLocation=D,r.FilterSystem.prototype.push=N,r.FilterSystem.prototype.pushWithCheck=A,r.FilterSystem.prototype.pop=S,r.FilterSystem.prototype.prepareBackdrop=Y}k(),e.BackdropFilter=o,e.BlendFilter=u,e.FlipYFilter=c,e.HARDLIGHT_FULL=x,e.HARDLIGHT_PART=F,e.MULTIPLY_FULL=y,e.MULTIPLY_PART="vec3 B = Cs * Cb;\n",e.MaskConfig=d,e.MaskFilter=f,e.NPM_BLEND=b,e.OVERLAY_FULL=g,e.OVERLAY_PART=m,e.SOFTLIGHT_FULL=_,e.SOFTLIGHT_PART=C,e.Sprite=class extends n.Sprite{_render(e){const r=this._texture;if(!r||!r.valid)return;const n=L(this.blendMode),i=this.blendMode;if(n){if(e.batch.flush(),!e.filter.pushWithCheck(this,n))return;this.blendMode=t.BLEND_MODES.NORMAL}this.calculateVertices(),e.batch.setObjectRenderer(e.plugins[this.pluginName]),e.plugins[this.pluginName].render(this),n&&(e.batch.flush(),e.filter.pop(),this.blendMode=i)}},e.TilingSprite=class extends i.TilingSprite{_render(e){const r=this._texture;if(!r||!r.valid)return;const t=L(this.blendMode);t&&(e.batch.flush(),!e.filter.pushWithCheck(this,t))||(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),e.batch.setObjectRenderer(e.plugins[this.pluginName]),e.plugins[this.pluginName].render(this),t&&(e.batch.flush(),e.filter.pop()))}},e.applyMixins=k,e.blendFullArray=T,e.getBlendFilter=v,e.getBlendFilterArray=L,Object.defineProperty(e,"__esModule",{value:!0})}),"undefined"!=typeof _pixi_picture&&Object.assign(this.PIXI.picture,_pixi_picture);